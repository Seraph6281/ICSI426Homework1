import java.util.Collections;
import java.util.List;
import java.util.Random;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

/**
 * Provides Row Transposition Cipher encryption.
 * Supports generating random keys for encryption.
 * @author Yingzhao (Seraph) Ma
 * @version 1.1
 */
public class RowTrans {

    /**
     * Generates a random key for row transposition cipher encryption based on the length of the given plaintext.
     * The key is a randomly shuffled sequence of integers ranging from 0 to the length of the plaintext, exclusive.
     *
     * @param plainText the plaintext for which the random key is generated; its length determines the key size
     * @return an array of integers representing the randomly shuffled key sequence for the row transposition cipher
     */
    public static Integer[] generateRandomKey(String plainText) {
        int length = plainText.length();
        List<Integer> keyList = IntStream.range(0, length).boxed().collect(Collectors.toList());
        Collections.shuffle(keyList, new Random());
        return keyList.toArray(new Integer[0]);
    }

    /**
     * Encrypts the given plaintext using Row Transposition Cipher.
     * The plaintext is arranged into a grid of characters with a number of columns as defined by the key length.
     * The ciphertext is then generated by reading characters column-wise based on the order specified in the key.
     *
     * @param plainText the plaintext to be encrypted
     * @param key an array of integers representing the column order for the encryption; the length of the key determines the number of columns
     * @return a string representing the encrypted text (ciphertext) generated by the Row Transposition Cipher algorithm
     */
    public static String encrypt(String plainText, Integer[] key) {
        int columns = key.length;
        int rows = (int) Math.ceil((double) plainText.length() / columns);
        char[][] grid = new char[rows][columns];

        // Fills grid row-wise
        int index = 0;
        for (int r = 0; r < rows; r++) {
            for (int c = 0; c < columns; c++) {
                if (index < plainText.length()) {
                    grid[r][c] = plainText.charAt(index++);
                } else {
                    grid[r][c] = 'X'; // Padding if necessary
                }
            }
        }

        // Encrypts using column order from key
        StringBuilder cipherText = new StringBuilder();
        for (int col : key) {

            for (int r = 0; r < rows; r++) {
                cipherText.append(grid[r][col]);
            }
        }
        return cipherText.toString();
    }

    /**
     * ** As decryption is not required for this homework,  **
     * ** this method is implemented for test purpose only. **
     * Decrypts the given ciphertext that was encrypted using a Row Transposition Cipher.
     * The decryption is performed using the provided key by rearranging the characters
     * into their original order based on the reverse mapping of the key and reading them row-wise.
     *
     * @param cipherText the ciphertext to be decrypted, which may include padding characters
     * @param key an array of integers representing the column order used during encryption;
     *            its length determines the number of columns in the transposition grid
     * @return the decrypted plaintext string with any padding characters removed
     */
    public static String decrypt(String cipherText, Integer[] key) {
        int columns = key.length;
        int rows = (int) Math.ceil((double) cipherText.length() / columns);
        char[][] grid = new char[rows][columns];

        int index = 0;
        // Reverses key mapping to restore original order
        Integer[] reverseKey = new Integer[key.length];
        for (int i = 0; i < key.length; i++) {
            reverseKey[key[i]] = i;
        }

        // Fills the grid column-wise based on key order
        for (int col : reverseKey) {
            for (int r = 0; r < rows; r++) {
                grid[r][col] = cipherText.charAt(index++);
            }
        }

        // Reads plaintext row-wise
        StringBuilder plainText = new StringBuilder();
        for (int r = 0; r < rows; r++) {
            for (int c = 0; c < columns; c++) {
                plainText.append(grid[r][c]);
            }
        }
        return plainText.toString().replace("X", ""); // Removes padding
    }
}

